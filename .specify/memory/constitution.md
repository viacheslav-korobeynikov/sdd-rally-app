<!--
Отчёт о синхронизации:
- Изменение версии: 1.0.0 → 1.1.0
- Изменённые принципы: Все принципы переведены на русский язык
- Добавленные разделы: N/A
- Удалённые разделы: N/A
- Статус шаблонов:
  ✅ plan-template.md - Раздел Constitution Check соответствует принципам
  ✅ spec-template.md - Структура требований поддерживает доменное моделирование
  ✅ tasks-template.md - Организация задач поддерживает модульную архитектуру
- Последующие TODO: Перевести шаблоны на русский язык
- Примечания: MINOR версия (1.1.0) - материальное расширение: добавлен русский язык как официальный язык документации
-->

# Конституция SDD Rally App

**Проект**: Веб-приложение для организаторов автомобильных ралли 3 категории (регистрация соревнований, управление спецучастками, заявками экипажей, классификацией результатов).

**Цель**: Единая платформа для подготовки и проведения ралли, минимизации ручной работы организаторов и снижения рисков ошибок в протоколах.

## Основные принципы

### I. Архитектура модульного монолита

**Правило**: Приложение ДОЛЖНО быть структурировано как модульный монолит с чёткими границами доменов: соревнования, маршруты/спецучастки, экипажи и участники, результаты. Код и слои ДОЛЖНЫ быть организованы так, чтобы в будущем можно было выделить части в отдельные сервисы без больших переписываний.

**Обоснование**: Организация ралли включает различные домены, которые развиваются независимо. Старт с монолита снижает операционную сложность, а чёткие границы позволяют масштабировать систему в будущем. Такой подход избегает преждевременного разделения на микросервисы, предотвращая антипаттерн «большой комок грязи».

**Требования**:
- Каждый доменный модуль ДОЛЖЕН иметь чёткие интерфейсы и минимальную связанность между доменами
- Общее ядро (shared kernel: общие типы, утилиты) ДОЛЖНО быть явно определено и версионировано
- Межмодульное взаимодействие ДОЛЖНО происходить через определённые интерфейсы сервисов, а не напрямую через репозитории
- Границы модулей ДОЛЖНЫ соответствовать этапам рабочего процесса организации ралли

### II. Чистая архитектура backend (Golang + Fiber)

**Правило**: Backend ДОЛЖЕН быть единым сервисом на Golang с использованием фреймворка Fiber и REST/HTTP API. Архитектура ДОЛЖНА следовать чистой архитектуре со слоями (handler/service/repository). Контекст запроса ДОЛЖЕН передаваться по всей цепочке вызовов. Middleware для логирования, трейсинга и аутентификации ОБЯЗАТЕЛЬНЫ. Прямое обращение к базе данных из обработчиков запросов СТРОГО ЗАПРЕЩЕНО.

**Обоснование**: Чистая архитектура обеспечивает тестируемость, поддерживаемость и чёткое разделение ответственности. Golang предоставляет производительность и типобезопасность, критичные для операций ралли, чувствительных к времени. Fiber обеспечивает минимальные накладные расходы для HTTP операций. Передача контекста позволяет распределённое трейсирование и отмену запросов.

**Требования**:
- **Слой handler**: Обработка HTTP запросов/ответов, валидация, сериализация
- **Слой service**: Бизнес-логика, оркестрация, границы транзакций
- **Слой repository**: Персистентность данных, построение запросов, взаимодействие с БД
- Все запросы ДОЛЖНЫ передавать context.Context для отмены и метаданных
- Middleware ДОЛЖНЫ регистрироваться в централизованной конфигурации роутера
- Транзакции БД ДОЛЖНЫ управляться на уровне service, не в handlers

### III. Серверный рендеринг (Templ + HTMX)

**Правило**: Frontend ДОЛЖЕН использовать серверный рендеринг с шаблонами Templ и HTMX для интерактивности. Максимум бизнес-логики ДОЛЖЕН оставаться на backend. HTMX ДОЛЖЕН использоваться для интерактивных обновлений (таблицы заявок, протоколы, фильтры). SPA-фреймворки (React, Vue, Angular) ЗАПРЕЩЕНЫ.

**Обоснование**: Организаторам ралли нужны надёжные, быстро загружающиеся интерфейсы, работающие на различных устройствах, включая старое оборудование на местах проведения гонок. Серверный рендеринг устраняет сложность JavaScript-сборки, снижает количество клиентских ошибок и обеспечивает консистентный рендеринг. HTMX обеспечивает прогрессивное улучшение для динамических обновлений без сложности SPA.

**Требования**:
- Весь HTML ДОЛЖЕН генерироваться на сервере с использованием шаблонов Templ
- HTMX ДОЛЖЕН обрабатывать частичные обновления страниц (строки таблиц, статусные бейджи, обратную связь валидации форм)
- JavaScript ДОЛЖЕН быть ограничен конфигурацией HTMX и минимальной полировкой UI (без бизнес-логики)
- Формы ДОЛЖНЫ работать без JavaScript (прогрессивное улучшение)
- Шаблоны ДОЛЖНЫ быть организованы по доменным модулям в соответствии со структурой backend

### IV. База данных как источник истины (PostgreSQL)

**Правило**: PostgreSQL является единственным источником истины. Доменные сущности (соревнование, спецучасток, экипаж, пилот, автомобиль, результаты, штрафы) ДОЛЖНЫ быть строго нормализованы. Бизнес-логика в триггерах и хранимых процедурах СТРОГО ЗАПРЕЩЕНА, за исключением технических/аудит-кейсов (created_at, updated_at, audit logs).

**Обоснование**: Результаты ралли требуют абсолютной целостности данных и аудит-следов. PostgreSQL обеспечивает ACID-гарантии, проверку внешних ключей и возможности сложных запросов, необходимых для расчёта результатов. Сохранение бизнес-логики в коде приложения (не в БД) обеспечивает тестируемость и контроль версий.

**Требования**:
- Все доменные сущности ДОЛЖНЫ иметь явные первичные ключи (предпочтительно UUID для распределённых сценариев)
- Ограничения внешних ключей ДОЛЖНЫ быть определены для всех связей
- Индексы ДОЛЖНЫ быть добавлены для всех паттернов запросов (list, filter, sort операции)
- Миграции ДОЛЖНЫ быть версионированы и идемпотентны с использованием golang-migrate или аналога
- Функции БД разрешены ТОЛЬКО для: временных меток по умолчанию, аудит-триггеров, валидации типов данных
- Сложные вычисления (результаты, классификации) ДОЛЖНЫ происходить на уровне service, не в базе данных

### V. Аутентификация и авторизация

**Правило**: Пользователи ДОЛЖНЫ аутентифицироваться через имя пользователя/пароль, хранящиеся в базе данных в виде bcrypt или argon2 хеша. Ролевая модель доступа (RBAC) ОБЯЗАТЕЛЬНА с минимально необходимыми ролями: Главный организатор, Секретарь, Хронометраж, Наблюдатель (только чтение). ДОЛЖЕН применяться принцип минимальных привилегий. Секреты НЕ ДОЛЖНЫ храниться в репозитории.

**Обоснование**: Данные ралли включают персональную информацию (водительские удостоверения, регистрации транспортных средств), требующую контролируемого доступа. Ролевая модель отражает реальную структуру организации ралли. Хеширование паролей защищает от утечек базы данных. Секреты в коде создают уязвимости безопасности.

**Требования**:
- Пароли ДОЛЖНЫ быть захешированы bcrypt (cost 12+) или argon2id перед сохранением
- Сессии ДОЛЖНЫ использовать безопасные, HTTP-only куки с CSRF-защитой
- Каждый эндпоинт ДОЛЖЕН декларировать требуемую роль(и) через middleware
- Секреты (пароли БД, ключи сессий) ДОЛЖНЫ предоставляться через переменные окружения или систему управления секретами
- Неудачные попытки входа ДОЛЖНЫ логироваться для мониторинга безопасности
- Назначения ролей ДОЛЖНЫ быть аудируемыми (кто выдал, когда, кому)

### VI. Domain-Driven Design для домена ралли

**Правило**: Доменные модели ДОЛЖНЫ явно представлять специфичные концепции ралли: классы автомобилей, группы, зачёты, стартовые ведомости, протоколы результатов, штрафы за опоздание/опережение и т.д. Все бизнес-правила из регламента ралли ДОЛЖНЫ быть кодифицированы в приложении или задокументированы в смежных файлах спецификаций.

**Обоснование**: Организация ралли имеет сложные доменные правила (классификация по классам и группам, расчёты времени со штрафами, управление последовательностью спецучастков), которые не могут быть отражены общими моделями. Явное доменное моделирование предотвращает недопонимание и позволяет валидировать правила.

**Требования**:
- Единый язык (ubiquitous language): идентификаторы в коде ДОЛЖНЫ соответствовать официальным терминам регламента ралли
- Доменные модели ДОЛЖНЫ быть независимы от слоя персистентности (никаких ORM-аннотаций в основных сущностях)
- Валидация бизнес-правил ДОЛЖНА происходить в методах доменных сервисов
- Сложные вычисления (классификация результатов, применение штрафов) ДОЛЖНЫ иметь unit-тесты
- Ссылки на регламент ДОЛЖНЫ быть документированы в комментариях кода или связанных файлах спецификаций

### VII. Наблюдаемость и качество

**Правило**: Логи ДОЛЖНЫ быть структурированными (JSON формат). Базовые метрики ДОЛЖНЫ собираться: количество заявок, время генерации отчётов, ошибки API. Unit-тесты ОБЯЗАТЕЛЬНЫ для критичных доменных сервисов (расчёт результатов, применение штрафов).

**Обоснование**: События ралли проходят в условиях временного давления с высокими ставками (официальные результаты, апелляции). Структурированные логи обеспечивают быстрое устранение проблем. Метрики выявляют узкие места производительности. Тесты предотвращают регрессии в логике вычислений, которые могут аннулировать результаты соревнований.

**Требования**:
- Все логи ДОЛЖНЫ использовать библиотеку структурированного логирования (zerolog, zap или slog)
- Уровни логирования ДОЛЖНЫ быть: DEBUG (разработка), INFO (значимые события), WARN (восстанавливаемые ошибки), ERROR (сбои, требующие внимания)
- Метрики ДОЛЖНЫ включать: длительность HTTP-запросов, длительность запросов к БД, активные сессии, количество заявок на соревнование
- Критичные сервисы ДОЛЖНЫ иметь >80% покрытие тестами для логики вычислений
- Интеграционные тесты ДОЛЖНЫ покрывать полные пользовательские сценарии (создать соревнование → принять заявки → ввести результаты → сгенерировать протокол)

### VIII. Семантическое версионирование

**Правило**: Релизы платформы ДОЛЖНЫ следовать семантическому версионированию (MAJOR.MINOR.PATCH). Изменения ДОЛЖНЫ отслеживаться в CHANGELOG.md.

**Обоснование**: Организаторам ралли нужно понимать влияние обновлений. Семантическое версионирование сообщает о breaking changes (MAJOR), новых функциях (MINOR) и исправлениях ошибок (PATCH). Changelog предоставляет руководство по обновлению.

**Требования**:
- MAJOR версия: Изменения схемы БД, требующие миграции, изменения контракта API, изменения модели ролей/прав
- MINOR версия: Новые функции (новые эндпоинты, новые доменные сущности), обратно совместимые добавления API
- PATCH версия: Исправления ошибок, улучшения производительности, обновления документации
- Каждый релиз ДОЛЖЕН иметь запись в changelog с датой, версией и категоризированными изменениями

### IX. Стандарты безопасности

**Правило**: Приложение ДОЛЖНО защищать от типичных веб-уязвимостей (CSRF, XSS, SQL-инъекции). Запросы к БД ДОЛЖНЫ использовать параметризованные выражения. Конфигурация CORS ДОЛЖНА быть централизована и явна.

**Обоснование**: Данные ралли включают персональную информацию (PII) и чувствительные данные соревнований. Нарушения безопасности могут скомпрометировать личные данные или целостность соревнований. Эшелонированная защита требует нескольких уровней защиты.

**Требования**:
- CSRF-токены ДОЛЖНЫ быть обязательны для всех операций, изменяющих состояние (POST, PUT, DELETE)
- Весь контент, предоставленный пользователями, ДОЛЖЕН экранироваться в HTML-шаблонах (Templ делает это по умолчанию)
- SQL-запросы ДОЛЖНЫ использовать параметризованные выражения или query builders, никогда не конкатенацию строк
- CORS ДОЛЖЕН быть настроен явно: разрешённые источники, методы, политика credentials
- Загрузка файлов (если реализована) ДОЛЖНА валидировать типы файлов и сканировать на вредоносный контент
- Заголовки безопасности ДОЛЖНЫ быть установлены: Content-Security-Policy, X-Frame-Options, X-Content-Type-Options

## Стандарты разработки

### Git-процесс

**Процесс**: Ветки функций ДОЛЖНЫ использоваться для всех изменений. Code review ОБЯЗАТЕЛЕН перед слиянием. Линтеры ДОЛЖНЫ проходить перед слиянием.

**Требования**:
- Именование веток: `feature/<номер-задачи>-<краткое-описание>`, `fix/<номер-задачи>-<краткое-описание>`
- Коммиты ДОЛЖНЫ следовать формату Conventional Commits: `type(scope): description`
- Pull requests ДОЛЖНЫ включать: описание, ссылку на задачу, изменения покрытия тестами
- Требуется минимум одно одобрение перед слиянием
- Линтер (golangci-lint) ДОЛЖЕН проходить без ошибок

### Документация

**Документация Backend ДОЛЖНА включать**:
- README.md: Обзор проекта, инструкции по настройке, переменные окружения
- Диаграмма доменных сущностей: Визуальное представление ключевых сущностей и связей
- Документация API-эндпоинтов: Метод, путь, примеры запросов/ответов для основных эндпоинтов
- Architecture Decision Records (ADR): Документация ключевых технических решений с контекстом и обоснованием

**Документация Frontend ДОЛЖНА включать**:
- Карта экранов: Основные экраны и навигационный поток (регистрация, управление СУ, списки экипажей, протоколы)
- Организация компонентов: Как структурированы и переиспользуются шаблоны
- HTMX паттерны: Общие паттерны взаимодействия, используемые в приложении

### Миграции баз данных

**Правило**: Изменения схемы БД ДОЛЖНЫ использовать инструмент миграций (golang-migrate или аналог). Миграции ДОЛЖНЫ храниться в репозитории. Ручные изменения схемы в продакшене ЗАПРЕЩЕНЫ.

**Требования**:
- Каждая миграция ДОЛЖНА иметь скрипты up и down
- Файлы миграций ДОЛЖНЫ нумероваться последовательно
- Миграции ДОЛЖНЫ быть идемпотентными, где возможно
- Миграции данных ДОЛЖНЫ быть отделены от миграций схемы
- Процедуры отката ДОЛЖНЫ тестироваться в staging окружении

## Инфраструктура и окружения

### Локальная разработка

**Настройка**: Docker Compose ДОЛЖЕН предоставлять полное локальное окружение, включая Golang backend, PostgreSQL базу данных и любые вспомогательные инструменты (runners миграций, seed-данные).

**Требования**:
- `docker-compose up` ДОЛЖЕН запускать полностью функциональное локальное окружение
- Пример данных ДОЛЖЕН быть предоставлен для разработки (примеры соревнований, экипажей, результатов)
- Конфигурация для конкретного окружения ДОЛЖНА использовать `.env.local` (в gitignore)
- Hot reload ДОЛЖЕН быть включен для изменений кода backend

### Staging и Production

**Развёртывание**: Приложения ДОЛЖНЫ быть контейнеризованы с использованием Docker. Инфраструктура ДОЛЖНА быть спроектирована для будущего развёртывания в Kubernetes. Конфигурация ДОЛЖНА быть вынесена через переменные окружения и управление секретами.

**Требования**:
- Отдельные окружения: development, staging, production
- Конфигурация для каждого окружения: подключение к БД, секреты сессий, CORS origins
- Секреты ДОЛЖНЫ управляться через систему управления секретами (не файлы окружения в репозитории)
- Резервные копии БД ДОЛЖНЫ быть автоматизированы для staging и production
- Стратегия миграций: миграции выполняются перед развёртыванием приложения, с планом отката

## Связанная документация

Эта конституция ссылается на следующие документы и поддерживается ими:

### Каталог сервисов / модулей
**Расположение**: `docs/architecture/module-catalog.md`

**Содержание**: Детальная разбивка доменных модулей (competitions, stages, crews, timing, results, documents), включая ответственность, открытые интерфейсы и зависимости.

### API-контракты
**Расположение**: директория `docs/api/` или `specs/<feature>/contracts/`

**Содержание**: Спецификации HTTP-эндпоинтов, включая схемы запросов/ответов для backend-сервиса. Предпочтительны определения OpenAPI/Swagger.

### Руководство по QA / тестированию
**Расположение**: `docs/testing/guidelines.md`

**Содержание**: Требования к тестированию, включая доменные правила, которые ДОЛЖНЫ быть покрыты unit-тестами, сценарии интеграционных тестов и критерии приёмки для критичных workflow.

### Наблюдаемость
**Расположение**: `docs/operations/observability.md`

**Содержание**: Стандарты логирования (уровни логов, структурированный формат), сбор метрик, дашборды мониторинга, правила алертинга для продакшена.

### Безопасность
**Расположение**: `docs/security/standards.md`

**Содержание**: Детальные требования безопасности, включая политики паролей, определения ролей и прав, процедуры хранения секретов, обработку персональных данных (соображения GDPR) и процедуры реагирования на инциденты.

## Внешние ссылки и лучшие практики

При принятии технических решений относительно внешних библиотек, протоколов или лучших практик, документация ДОЛЖНА консультироваться через инструмент Ref MCP для обеспечения соответствия текущим стандартам и рекомендациям сообщества.

**Области, требующие валидации по справочной документации**:
- Выбор Golang фреймворков и библиотек
- Паттерны проектирования схем PostgreSQL
- Реализации безопасности (хеширование, управление сессиями, CSRF-защита)
- Паттерны взаимодействия HTMX
- Лучшие практики Docker и Kubernetes

## Управление

### Процедура внесения поправок

1. **Предложение**: Поправки ДОЛЖНЫ предлагаться через pull request с обоснованием и оценкой влияния
2. **Ревью**: Как минимум один старший инженер должен проверить предложенные поправки
3. **Обновление документации**: Все затронутые шаблоны и документация ДОЛЖНЫ быть обновлены в том же PR
4. **Повышение версии**: Версия конституции ДОЛЖНА быть увеличена согласно правилам семантического версионирования
5. **План миграции**: Если поправка влияет на существующий код, план миграции ДОЛЖЕН быть предоставлен

### Соответствие

- **Code Review**: Все pull requests ДОЛЖНЫ быть проверены на соответствие принципам конституции
- **Архитектурное ревью**: Новые функции ДОЛЖНЫ проходить архитектурное ревью на соответствие Основным принципам
- **Обоснование сложности**: Любое отклонение от конституции ДОЛЖНО быть явно обосновано в разделе Complexity Tracking файла `plan.md`
- **Ретроспектива**: Эффективность конституции ДОЛЖНА пересматриваться ежеквартально с обратной связью команды

### Правила версионирования

- **MAJOR**: Принцип удалён или фундаментально переопределён (breaking change в подходе к проекту)
- **MINOR**: Добавлен новый принцип, добавлен новый раздел или существующий принцип материально расширен
- **PATCH**: Уточнения, улучшения формулировок, исправления опечаток, изменения форматирования

### Руководство для выполнения

Для повседневных решений по разработке и руководства для AI-агентов, обращайтесь к `.specify/memory/agent-guidance.md`, который предоставляет операционную интерпретацию этих конституционных принципов.

---

**Версия**: 1.1.0 | **Ратифицировано**: 2025-12-17 | **Последнее изменение**: 2025-12-17
